// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_allocations.query.sql

package productallocations

import (
	"context"
	"time"
)

const createProductAllocation = `-- name: CreateProductAllocation :one
INSERT INTO product_allocations (
    product_id,
    shop_id,
    film_quantity,
    allocation_date,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id, product_id, shop_id, film_quantity, allocation_date, created_at, updated_at
`

type CreateProductAllocationParams struct {
	ProductID    int32 `db:"product_id" json:"productId"`
	ShopID       int32 `db:"shop_id" json:"shopId"`
	FilmQuantity int32 `db:"film_quantity" json:"filmQuantity"`
}

func (q *Queries) CreateProductAllocation(ctx context.Context, arg *CreateProductAllocationParams) (*ProductAllocation, error) {
	row := q.db.QueryRow(ctx, createProductAllocation, arg.ProductID, arg.ShopID, arg.FilmQuantity)
	var i ProductAllocation
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ShopID,
		&i.FilmQuantity,
		&i.AllocationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getProductAllocationByID = `-- name: GetProductAllocationByID :one
SELECT
    id,
    product_id,
    shop_id,
    film_quantity,
    allocation_date,
    created_at,
    updated_at
FROM product_allocations
WHERE id = $1
`

func (q *Queries) GetProductAllocationByID(ctx context.Context, id int32) (*ProductAllocation, error) {
	row := q.db.QueryRow(ctx, getProductAllocationByID, id)
	var i ProductAllocation
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ShopID,
		&i.FilmQuantity,
		&i.AllocationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listProductAllocationsView = `-- name: ListProductAllocationsView :many
SELECT
    allocation_id,
    film_serial_number,
    product_name,
    shop_name,
    branch_code,
    film_quantity,
    allocation_date,
    created_at,
    updated_at
FROM product_allocations_view
ORDER BY allocation_date DESC
`

func (q *Queries) ListProductAllocationsView(ctx context.Context) ([]*ProductAllocationsView, error) {
	rows, err := q.db.Query(ctx, listProductAllocationsView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductAllocationsView{}
	for rows.Next() {
		var i ProductAllocationsView
		if err := rows.Scan(
			&i.AllocationID,
			&i.FilmSerialNumber,
			&i.ProductName,
			&i.ShopName,
			&i.BranchCode,
			&i.FilmQuantity,
			&i.AllocationDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductAllocation = `-- name: UpdateProductAllocation :one
UPDATE product_allocations
SET
    product_id = $2,
    shop_id = $3,
    film_quantity = $4,
    allocation_date = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, product_id, shop_id, film_quantity, allocation_date, created_at, updated_at
`

type UpdateProductAllocationParams struct {
	ID             int32     `db:"id" json:"id"`
	ProductID      int32     `db:"product_id" json:"productId"`
	ShopID         int32     `db:"shop_id" json:"shopId"`
	FilmQuantity   int32     `db:"film_quantity" json:"filmQuantity"`
	AllocationDate time.Time `db:"allocation_date" json:"allocationDate"`
}

func (q *Queries) UpdateProductAllocation(ctx context.Context, arg *UpdateProductAllocationParams) (*ProductAllocation, error) {
	row := q.db.QueryRow(ctx, updateProductAllocation,
		arg.ID,
		arg.ProductID,
		arg.ShopID,
		arg.FilmQuantity,
		arg.AllocationDate,
	)
	var i ProductAllocation
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ShopID,
		&i.FilmQuantity,
		&i.AllocationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
